<?php
/**
 * ReviewsApi
 * PHP version 5
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Zembra - API Reference
 *
 * Zembra is a REST API. It accepts standard verbs and returns JSON responses with standard HTTP response codes.    You can use the sandbox token and endpoints for testing. Using the sandbox does not affect your account's balance. Nevertheless, the same throttling applies to both live and sandbox environments. The sandbox randomly returns dummy data representing all different expected responses from an endpoint. The sandbox performs the same set of validation the live box does, including slug validation and eligibility for services.    Default throttling is set to **10000** calls per minute. Your account may have higher limit. If you don't know your current rate limit, contact your account manager or reach out to our [support team](mailto:contact@zembratech.com).  Each response returned by the API has throttling info added to the headers: - **X-RateLimit-Limit**: 10000 or -1 if no limit   The allocated rate limit to the account - **X-RateLimit-Remaining**: < 10000 or -1 if no limit   The number of remaining calls before hitting the throttling limit and start getting calls rejected until counter is reset.    Zembra has made available SDKs in many coding languages to help you quickly get started consuming the API with minimum effort:   - [C-Sharp](https://cdn.sdks.zembratech.com/zembra-sdk-csharp.zip) - [Go](https://cdn.sdks.zembratech.com/zembra-sdk-go.zip) - [Java](https://cdn.sdks.zembratech.com/zembra-sdk-java.zip) - [Kotlin](https://cdn.sdks.zembratech.com/zembra-sdk-kotlin.zip) - [PHP](https://cdn.sdks.zembratech.com/zembra-sdk-php.zip) - [Python](https://cdn.sdks.zembratech.com/zembra-sdk-python.zip) - [Scala](https://cdn.sdks.zembratech.com/zembra-sdk-scala.zip) - [Swift 3](https://cdn.sdks.zembratech.com/zembra-sdk-swift3.zip) - [Swift 4](https://cdn.sdks.zembratech.com/zembra-sdk-swift4.zip) - [Swift 5](https://cdn.sdks.zembratech.com/zembra-sdk-swift5.zip) - [Typescript Angular](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-angular.zip) - [Typescript Fetch](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-fetch.zip)  You can also download [Postman](https://www.postman.com/downloads/) then import this [collection](https://www.getpostman.com/collections/57d319ce3e3bb1150bc6) which includes calls the all Zembra API sandbox endpoints with a combination of all available parameters.
 *
 * OpenAPI spec version: 2.3.0
 * Contact: contact@zembratech.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Zembra Codegen version: 3.0.35
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Zembra\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zembra\Client\ApiException;
use Zembra\Client\Configuration;
use Zembra\Client\HeaderSelector;
use Zembra\Client\ObjectSerializer;

/**
 * ReviewsApi Class Doc Comment
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReviewsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation reviewsJobsGet
     *
     * Get the list of available review jobs
     *
     * @param  int $limit Maximum number of jobs to be returned. At most 100 jobs will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of jobs. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only jobs with similar internal ID. This is the ID you set on the job that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only jobs for review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns jobs for review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the job is returned as a &#x27;#/components/schemas/ReviewPageJob&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the job is set on field **job**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2006
     */
    public function reviewsJobsGet($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        list($response) = $this->reviewsJobsGetWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);
        return $response;
    }

    /**
     * Operation reviewsJobsGetWithHttpInfo
     *
     * Get the list of available review jobs
     *
     * @param  int $limit Maximum number of jobs to be returned. At most 100 jobs will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of jobs. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only jobs with similar internal ID. This is the ID you set on the job that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only jobs for review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns jobs for review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the job is returned as a &#x27;#/components/schemas/ReviewPageJob&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the job is set on field **job**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsJobsGetWithHttpInfo($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2006';
        $request = $this->reviewsJobsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsJobsGetAsync
     *
     * Get the list of available review jobs
     *
     * @param  int $limit Maximum number of jobs to be returned. At most 100 jobs will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of jobs. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only jobs with similar internal ID. This is the ID you set on the job that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only jobs for review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns jobs for review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the job is returned as a &#x27;#/components/schemas/ReviewPageJob&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the job is set on field **job**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsGetAsync($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        return $this->reviewsJobsGetAsyncWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsJobsGetAsyncWithHttpInfo
     *
     * Get the list of available review jobs
     *
     * @param  int $limit Maximum number of jobs to be returned. At most 100 jobs will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of jobs. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only jobs with similar internal ID. This is the ID you set on the job that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only jobs for review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns jobs for review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the job is returned as a &#x27;#/components/schemas/ReviewPageJob&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the job is set on field **job**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsGetAsyncWithHttpInfo($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2006';
        $request = $this->reviewsJobsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsJobsGet'
     *
     * @param  int $limit Maximum number of jobs to be returned. At most 100 jobs will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of jobs. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only jobs with similar internal ID. This is the ID you set on the job that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only jobs for review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns jobs for review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the job is returned as a &#x27;#/components/schemas/ReviewPageJob&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the job is set on field **job**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsJobsGetRequest($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {

        $resourcePath = '/reviews/jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($network !== null) {
            $queryParams['network'] = ObjectSerializer::toQueryValue($network, null);
        }
        // query params
        if ($include_page !== null) {
            $queryParams['includePage'] = ObjectSerializer::toQueryValue($include_page, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsJobsJobIdGet
     *
     * Get reviews for requested business from existing job
     *
     * @param  string $job_id The generated job ID that was returned by the API when the job was created. (required)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $include_raw_data Please see description for **includeRawData** on **reviews/subscriptions/{network}**. (optional, default to false)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2003
     */
    public function reviewsJobsJobIdGet($job_id, $limit = null, $offset = null, $include_raw_data = 'false')
    {
        list($response) = $this->reviewsJobsJobIdGetWithHttpInfo($job_id, $limit, $offset, $include_raw_data);
        return $response;
    }

    /**
     * Operation reviewsJobsJobIdGetWithHttpInfo
     *
     * Get reviews for requested business from existing job
     *
     * @param  string $job_id The generated job ID that was returned by the API when the job was created. (required)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $include_raw_data Please see description for **includeRawData** on **reviews/subscriptions/{network}**. (optional, default to false)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsJobsJobIdGetWithHttpInfo($job_id, $limit = null, $offset = null, $include_raw_data = 'false')
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2003';
        $request = $this->reviewsJobsJobIdGetRequest($job_id, $limit, $offset, $include_raw_data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse410',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 425:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse425',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsJobsJobIdGetAsync
     *
     * Get reviews for requested business from existing job
     *
     * @param  string $job_id The generated job ID that was returned by the API when the job was created. (required)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $include_raw_data Please see description for **includeRawData** on **reviews/subscriptions/{network}**. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsJobIdGetAsync($job_id, $limit = null, $offset = null, $include_raw_data = 'false')
    {
        return $this->reviewsJobsJobIdGetAsyncWithHttpInfo($job_id, $limit, $offset, $include_raw_data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsJobsJobIdGetAsyncWithHttpInfo
     *
     * Get reviews for requested business from existing job
     *
     * @param  string $job_id The generated job ID that was returned by the API when the job was created. (required)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $include_raw_data Please see description for **includeRawData** on **reviews/subscriptions/{network}**. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsJobIdGetAsyncWithHttpInfo($job_id, $limit = null, $offset = null, $include_raw_data = 'false')
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2003';
        $request = $this->reviewsJobsJobIdGetRequest($job_id, $limit, $offset, $include_raw_data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsJobsJobIdGet'
     *
     * @param  string $job_id The generated job ID that was returned by the API when the job was created. (required)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $include_raw_data Please see description for **includeRawData** on **reviews/subscriptions/{network}**. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsJobsJobIdGetRequest($job_id, $limit = null, $offset = null, $include_raw_data = 'false')
    {
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling reviewsJobsJobIdGet'
            );
        }

        $resourcePath = '/reviews/jobs/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($include_raw_data !== null) {
            $queryParams['includeRawData'] = ObjectSerializer::toQueryValue($include_raw_data, null);
        }

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsJobsNetworkPost
     *
     * Create a new review job
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  int $stream_size_limit Indicates the maximum number of reviews to be retrieved from the original website. A minimum of 25 reviews to be returned is enforced. This field controls the charges applied to the job. If 100 reviews are requested, a maximum of 100 most recent reviews will be returned even if the page has more than 100 reviews. The account will be charged for no more than 100 reviews. If the page has less than the requested limit, even if less than 25, the account is only charged for the number of returned reviews. If this parameter is omitted, all the reviews found on the review page will be returned and the account will be charged for all returned reviews. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id Please see description for **internalId on **_/reviews/subscriptions/{network}**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2011
     */
    public function reviewsJobsNetworkPost($network, $slug, $stream_size_limit = null, $include_raw_data = 'false', $internal_id = null)
    {
        list($response) = $this->reviewsJobsNetworkPostWithHttpInfo($network, $slug, $stream_size_limit, $include_raw_data, $internal_id);
        return $response;
    }

    /**
     * Operation reviewsJobsNetworkPostWithHttpInfo
     *
     * Create a new review job
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  int $stream_size_limit Indicates the maximum number of reviews to be retrieved from the original website. A minimum of 25 reviews to be returned is enforced. This field controls the charges applied to the job. If 100 reviews are requested, a maximum of 100 most recent reviews will be returned even if the page has more than 100 reviews. The account will be charged for no more than 100 reviews. If the page has less than the requested limit, even if less than 25, the account is only charged for the number of returned reviews. If this parameter is omitted, all the reviews found on the review page will be returned and the account will be charged for all returned reviews. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id Please see description for **internalId on **_/reviews/subscriptions/{network}**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2011, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsJobsNetworkPostWithHttpInfo($network, $slug, $stream_size_limit = null, $include_raw_data = 'false', $internal_id = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2011';
        $request = $this->reviewsJobsNetworkPostRequest($network, $slug, $stream_size_limit, $include_raw_data, $internal_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse404',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsJobsNetworkPostAsync
     *
     * Create a new review job
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  int $stream_size_limit Indicates the maximum number of reviews to be retrieved from the original website. A minimum of 25 reviews to be returned is enforced. This field controls the charges applied to the job. If 100 reviews are requested, a maximum of 100 most recent reviews will be returned even if the page has more than 100 reviews. The account will be charged for no more than 100 reviews. If the page has less than the requested limit, even if less than 25, the account is only charged for the number of returned reviews. If this parameter is omitted, all the reviews found on the review page will be returned and the account will be charged for all returned reviews. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id Please see description for **internalId on **_/reviews/subscriptions/{network}**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsNetworkPostAsync($network, $slug, $stream_size_limit = null, $include_raw_data = 'false', $internal_id = null)
    {
        return $this->reviewsJobsNetworkPostAsyncWithHttpInfo($network, $slug, $stream_size_limit, $include_raw_data, $internal_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsJobsNetworkPostAsyncWithHttpInfo
     *
     * Create a new review job
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  int $stream_size_limit Indicates the maximum number of reviews to be retrieved from the original website. A minimum of 25 reviews to be returned is enforced. This field controls the charges applied to the job. If 100 reviews are requested, a maximum of 100 most recent reviews will be returned even if the page has more than 100 reviews. The account will be charged for no more than 100 reviews. If the page has less than the requested limit, even if less than 25, the account is only charged for the number of returned reviews. If this parameter is omitted, all the reviews found on the review page will be returned and the account will be charged for all returned reviews. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id Please see description for **internalId on **_/reviews/subscriptions/{network}**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsJobsNetworkPostAsyncWithHttpInfo($network, $slug, $stream_size_limit = null, $include_raw_data = 'false', $internal_id = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2011';
        $request = $this->reviewsJobsNetworkPostRequest($network, $slug, $stream_size_limit, $include_raw_data, $internal_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsJobsNetworkPost'
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  int $stream_size_limit Indicates the maximum number of reviews to be retrieved from the original website. A minimum of 25 reviews to be returned is enforced. This field controls the charges applied to the job. If 100 reviews are requested, a maximum of 100 most recent reviews will be returned even if the page has more than 100 reviews. The account will be charged for no more than 100 reviews. If the page has less than the requested limit, even if less than 25, the account is only charged for the number of returned reviews. If this parameter is omitted, all the reviews found on the review page will be returned and the account will be charged for all returned reviews. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id Please see description for **internalId on **_/reviews/subscriptions/{network}**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsJobsNetworkPostRequest($network, $slug, $stream_size_limit = null, $include_raw_data = 'false', $internal_id = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsJobsNetworkPost'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsJobsNetworkPost'
            );
        }

        $resourcePath = '/reviews/jobs/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($stream_size_limit !== null) {
            $queryParams['streamSizeLimit'] = ObjectSerializer::toQueryValue($stream_size_limit, null);
        }
        // query params
        if ($include_raw_data !== null) {
            $queryParams['includeRawData'] = ObjectSerializer::toQueryValue($include_raw_data, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionsGet
     *
     * Get the list of active review subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the subscription is returned as a &#x27;#/components/schemas/ReviewPageSubscription&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the subscription is set on field **subscription**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2005
     */
    public function reviewsSubscriptionsGet($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        list($response) = $this->reviewsSubscriptionsGetWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionsGetWithHttpInfo
     *
     * Get the list of active review subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the subscription is returned as a &#x27;#/components/schemas/ReviewPageSubscription&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the subscription is set on field **subscription**. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionsGetWithHttpInfo($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2005';
        $request = $this->reviewsSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionsGetAsync
     *
     * Get the list of active review subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the subscription is returned as a &#x27;#/components/schemas/ReviewPageSubscription&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the subscription is set on field **subscription**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsGetAsync($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        return $this->reviewsSubscriptionsGetAsyncWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionsGetAsyncWithHttpInfo
     *
     * Get the list of active review subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the subscription is returned as a &#x27;#/components/schemas/ReviewPageSubscription&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the subscription is set on field **subscription**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsGetAsyncWithHttpInfo($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2005';
        $request = $this->reviewsSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $include_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionsGet'
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for **internalId** on **_/reviews/subscriptions/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for **slug** on **business/{network}/{slug}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     * @param  bool $include_page If omitted or set to **false**, the subscription is returned as a &#x27;#/components/schemas/ReviewPageSubscription&#x27; object. If set to include the review page, the returned object is of type &#x27;#/components/schemas/ReviewPage&#x27; and the subscription is set on field **subscription**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionsGetRequest($limit = null, $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $include_page = null)
    {

        $resourcePath = '/reviews/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($network !== null) {
            $queryParams['network'] = ObjectSerializer::toQueryValue($network, null);
        }
        // query params
        if ($include_page !== null) {
            $queryParams['includePage'] = ObjectSerializer::toQueryValue($include_page, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionsNetworkDelete
     *
     * Cancel auto-renew on a review page subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2004
     */
    public function reviewsSubscriptionsNetworkDelete($network, $slug)
    {
        list($response) = $this->reviewsSubscriptionsNetworkDeleteWithHttpInfo($network, $slug);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionsNetworkDeleteWithHttpInfo
     *
     * Cancel auto-renew on a review page subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionsNetworkDeleteWithHttpInfo($network, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2004';
        $request = $this->reviewsSubscriptionsNetworkDeleteRequest($network, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionsNetworkDeleteAsync
     *
     * Cancel auto-renew on a review page subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsNetworkDeleteAsync($network, $slug)
    {
        return $this->reviewsSubscriptionsNetworkDeleteAsyncWithHttpInfo($network, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionsNetworkDeleteAsyncWithHttpInfo
     *
     * Cancel auto-renew on a review page subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsNetworkDeleteAsyncWithHttpInfo($network, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2004';
        $request = $this->reviewsSubscriptionsNetworkDeleteRequest($network, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionsNetworkDelete'
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionsNetworkDeleteRequest($network, $slug)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionsNetworkDelete'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionsNetworkDelete'
            );
        }

        $resourcePath = '/reviews/subscriptions/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionsNetworkGet
     *
     * Get reviews for requested business from existing subscription or create new subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned (optional)
     * @param  bool $has_replies If requested, only reviews with replies from the business owner are returned (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. (optional)
     * @param  bool $is_hidden If requested, only reviews that are kept hidden on the review platfom returned, e.g. non-recommended reviews on Yelp (optional)
     * @param  bool $is_not_hidden If requested, only reviews that are active and visible on the review platfom returned (optional)
     * @param  bool $is_recommended If requested, only reviews considered as positive recommendation (recommended) are returned (optional)
     * @param  bool $is_not_recommended If requested, only reviews considered as negative recommendation (not recommended) are returned (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  bool $include_deleted If requested, the result includes reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $auto_renew When a subscription to a review page is created, it is set to expire after 30 days from the moment it was first requested. If you wish to continuously receive updates and never miss a review, you can instruct Zembra to automatically renew the subscription when it expires. This results in a new charge for the review page. If insufficient funds found in the account, the subscription is canceled and it does not restart even if you reload your balance. If we fail to renew the subscription, we send you an email notification if not unsusbcribed from that email list, and in-app notification. Canceled subscriptions have to be restarted the same way they were first created.   Omitting this fied keeps it unchanged. If you want to cancel auto-renew, simply set this field to false. Cancelling auto-renew does not affect your current subscription.   A subscription is by default set *NOT* to auto-renew because the user&#x27;s consent is required. However, once the subscription is set to auto-renew, you have to be explicitly cancel the subscription to disable auto-renew by setting this field to **false** or using the API verb **delete** without parameters. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the review page, particularly when you activate listeners and we send you a change notification. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2003
     */
    public function reviewsSubscriptionsNetworkGet($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_not_hidden = null, $is_recommended = null, $is_not_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = null, $offset = null, $auto_renew = null, $include_raw_data = 'false', $internal_id = null)
    {
        list($response) = $this->reviewsSubscriptionsNetworkGetWithHttpInfo($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_not_hidden, $is_recommended, $is_not_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $include_deleted, $sort_by, $sort_direction, $limit, $offset, $auto_renew, $include_raw_data, $internal_id);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionsNetworkGetWithHttpInfo
     *
     * Get reviews for requested business from existing subscription or create new subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned (optional)
     * @param  bool $has_replies If requested, only reviews with replies from the business owner are returned (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. (optional)
     * @param  bool $is_hidden If requested, only reviews that are kept hidden on the review platfom returned, e.g. non-recommended reviews on Yelp (optional)
     * @param  bool $is_not_hidden If requested, only reviews that are active and visible on the review platfom returned (optional)
     * @param  bool $is_recommended If requested, only reviews considered as positive recommendation (recommended) are returned (optional)
     * @param  bool $is_not_recommended If requested, only reviews considered as negative recommendation (not recommended) are returned (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  bool $include_deleted If requested, the result includes reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $auto_renew When a subscription to a review page is created, it is set to expire after 30 days from the moment it was first requested. If you wish to continuously receive updates and never miss a review, you can instruct Zembra to automatically renew the subscription when it expires. This results in a new charge for the review page. If insufficient funds found in the account, the subscription is canceled and it does not restart even if you reload your balance. If we fail to renew the subscription, we send you an email notification if not unsusbcribed from that email list, and in-app notification. Canceled subscriptions have to be restarted the same way they were first created.   Omitting this fied keeps it unchanged. If you want to cancel auto-renew, simply set this field to false. Cancelling auto-renew does not affect your current subscription.   A subscription is by default set *NOT* to auto-renew because the user&#x27;s consent is required. However, once the subscription is set to auto-renew, you have to be explicitly cancel the subscription to disable auto-renew by setting this field to **false** or using the API verb **delete** without parameters. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the review page, particularly when you activate listeners and we send you a change notification. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionsNetworkGetWithHttpInfo($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_not_hidden = null, $is_recommended = null, $is_not_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = null, $offset = null, $auto_renew = null, $include_raw_data = 'false', $internal_id = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2003';
        $request = $this->reviewsSubscriptionsNetworkGetRequest($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_not_hidden, $is_recommended, $is_not_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $include_deleted, $sort_by, $sort_direction, $limit, $offset, $auto_renew, $include_raw_data, $internal_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse201',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse404',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 425:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse425',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionsNetworkGetAsync
     *
     * Get reviews for requested business from existing subscription or create new subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned (optional)
     * @param  bool $has_replies If requested, only reviews with replies from the business owner are returned (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. (optional)
     * @param  bool $is_hidden If requested, only reviews that are kept hidden on the review platfom returned, e.g. non-recommended reviews on Yelp (optional)
     * @param  bool $is_not_hidden If requested, only reviews that are active and visible on the review platfom returned (optional)
     * @param  bool $is_recommended If requested, only reviews considered as positive recommendation (recommended) are returned (optional)
     * @param  bool $is_not_recommended If requested, only reviews considered as negative recommendation (not recommended) are returned (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  bool $include_deleted If requested, the result includes reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $auto_renew When a subscription to a review page is created, it is set to expire after 30 days from the moment it was first requested. If you wish to continuously receive updates and never miss a review, you can instruct Zembra to automatically renew the subscription when it expires. This results in a new charge for the review page. If insufficient funds found in the account, the subscription is canceled and it does not restart even if you reload your balance. If we fail to renew the subscription, we send you an email notification if not unsusbcribed from that email list, and in-app notification. Canceled subscriptions have to be restarted the same way they were first created.   Omitting this fied keeps it unchanged. If you want to cancel auto-renew, simply set this field to false. Cancelling auto-renew does not affect your current subscription.   A subscription is by default set *NOT* to auto-renew because the user&#x27;s consent is required. However, once the subscription is set to auto-renew, you have to be explicitly cancel the subscription to disable auto-renew by setting this field to **false** or using the API verb **delete** without parameters. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the review page, particularly when you activate listeners and we send you a change notification. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsNetworkGetAsync($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_not_hidden = null, $is_recommended = null, $is_not_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = null, $offset = null, $auto_renew = null, $include_raw_data = 'false', $internal_id = null)
    {
        return $this->reviewsSubscriptionsNetworkGetAsyncWithHttpInfo($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_not_hidden, $is_recommended, $is_not_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $include_deleted, $sort_by, $sort_direction, $limit, $offset, $auto_renew, $include_raw_data, $internal_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionsNetworkGetAsyncWithHttpInfo
     *
     * Get reviews for requested business from existing subscription or create new subscription
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned (optional)
     * @param  bool $has_replies If requested, only reviews with replies from the business owner are returned (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. (optional)
     * @param  bool $is_hidden If requested, only reviews that are kept hidden on the review platfom returned, e.g. non-recommended reviews on Yelp (optional)
     * @param  bool $is_not_hidden If requested, only reviews that are active and visible on the review platfom returned (optional)
     * @param  bool $is_recommended If requested, only reviews considered as positive recommendation (recommended) are returned (optional)
     * @param  bool $is_not_recommended If requested, only reviews considered as negative recommendation (not recommended) are returned (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  bool $include_deleted If requested, the result includes reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $auto_renew When a subscription to a review page is created, it is set to expire after 30 days from the moment it was first requested. If you wish to continuously receive updates and never miss a review, you can instruct Zembra to automatically renew the subscription when it expires. This results in a new charge for the review page. If insufficient funds found in the account, the subscription is canceled and it does not restart even if you reload your balance. If we fail to renew the subscription, we send you an email notification if not unsusbcribed from that email list, and in-app notification. Canceled subscriptions have to be restarted the same way they were first created.   Omitting this fied keeps it unchanged. If you want to cancel auto-renew, simply set this field to false. Cancelling auto-renew does not affect your current subscription.   A subscription is by default set *NOT* to auto-renew because the user&#x27;s consent is required. However, once the subscription is set to auto-renew, you have to be explicitly cancel the subscription to disable auto-renew by setting this field to **false** or using the API verb **delete** without parameters. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the review page, particularly when you activate listeners and we send you a change notification. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsNetworkGetAsyncWithHttpInfo($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_not_hidden = null, $is_recommended = null, $is_not_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = null, $offset = null, $auto_renew = null, $include_raw_data = 'false', $internal_id = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2003';
        $request = $this->reviewsSubscriptionsNetworkGetRequest($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_not_hidden, $is_recommended, $is_not_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $include_deleted, $sort_by, $sort_direction, $limit, $offset, $auto_renew, $include_raw_data, $internal_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionsNetworkGet'
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for **slug** on **business/{network}/{slug}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned (optional)
     * @param  bool $has_replies If requested, only reviews with replies from the business owner are returned (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. (optional)
     * @param  bool $is_hidden If requested, only reviews that are kept hidden on the review platfom returned, e.g. non-recommended reviews on Yelp (optional)
     * @param  bool $is_not_hidden If requested, only reviews that are active and visible on the review platfom returned (optional)
     * @param  bool $is_recommended If requested, only reviews considered as positive recommendation (recommended) are returned (optional)
     * @param  bool $is_not_recommended If requested, only reviews considered as negative recommendation (not recommended) are returned (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format **Y-m-d H:i:s** or any derivative starting from the left, e.g. **Y** or **Y-m**, etc. (optional)
     * @param  bool $include_deleted If requested, the result includes reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned (optional)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     * @param  bool $auto_renew When a subscription to a review page is created, it is set to expire after 30 days from the moment it was first requested. If you wish to continuously receive updates and never miss a review, you can instruct Zembra to automatically renew the subscription when it expires. This results in a new charge for the review page. If insufficient funds found in the account, the subscription is canceled and it does not restart even if you reload your balance. If we fail to renew the subscription, we send you an email notification if not unsusbcribed from that email list, and in-app notification. Canceled subscriptions have to be restarted the same way they were first created.   Omitting this fied keeps it unchanged. If you want to cancel auto-renew, simply set this field to false. Cancelling auto-renew does not affect your current subscription.   A subscription is by default set *NOT* to auto-renew because the user&#x27;s consent is required. However, once the subscription is set to auto-renew, you have to be explicitly cancel the subscription to disable auto-renew by setting this field to **false** or using the API verb **delete** without parameters. (optional)
     * @param  bool $include_raw_data You can request to include the original data collected from the native site. The raw data may include additional information that is not parsed by default by the API. Example of raw data can be user email address, or number of followers, etc. When setting this flag to true, the review page subscription is updated. As a consequence, if you happen to have listeners enabled, e.g. HTTP webhook where you receive updates for a review page, the payload will include raw data. Including raw data may drive the size of the data to be considerably large. Some servers may reject POST requests with large payload. (optional, default to false)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the review page, particularly when you activate listeners and we send you a change notification. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionsNetworkGetRequest($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_not_hidden = null, $is_recommended = null, $is_not_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = null, $offset = null, $auto_renew = null, $include_raw_data = 'false', $internal_id = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionsNetworkGet'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionsNetworkGet'
            );
        }

        $resourcePath = '/reviews/subscriptions/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if (is_array($fields)) {
            $fields = ObjectSerializer::serializeCollection($fields, 'multi', true);
        }
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($has_photos !== null) {
            $queryParams['hasPhotos'] = ObjectSerializer::toQueryValue($has_photos, null);
        }
        // query params
        if ($has_replies !== null) {
            $queryParams['hasReplies'] = ObjectSerializer::toQueryValue($has_replies, null);
        }
        // query params
        if ($has_edits !== null) {
            $queryParams['hasEdits'] = ObjectSerializer::toQueryValue($has_edits, null);
        }
        // query params
        if ($is_hidden !== null) {
            $queryParams['isHidden'] = ObjectSerializer::toQueryValue($is_hidden, null);
        }
        // query params
        if ($is_not_hidden !== null) {
            $queryParams['isNotHidden'] = ObjectSerializer::toQueryValue($is_not_hidden, null);
        }
        // query params
        if ($is_recommended !== null) {
            $queryParams['isRecommended'] = ObjectSerializer::toQueryValue($is_recommended, null);
        }
        // query params
        if ($is_not_recommended !== null) {
            $queryParams['isNotRecommended'] = ObjectSerializer::toQueryValue($is_not_recommended, null);
        }
        // query params
        if ($max_rating !== null) {
            $queryParams['maxRating'] = ObjectSerializer::toQueryValue($max_rating, 'float');
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating, 'float');
        }
        // query params
        if ($posted_before !== null) {
            $queryParams['postedBefore'] = ObjectSerializer::toQueryValue($posted_before, 'date');
        }
        // query params
        if ($posted_after !== null) {
            $queryParams['postedAfter'] = ObjectSerializer::toQueryValue($posted_after, 'date');
        }
        // query params
        if ($include_deleted !== null) {
            $queryParams['includeDeleted'] = ObjectSerializer::toQueryValue($include_deleted, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($auto_renew !== null) {
            $queryParams['autoRenew'] = ObjectSerializer::toQueryValue($auto_renew, null);
        }
        // query params
        if ($include_raw_data !== null) {
            $queryParams['includeRawData'] = ObjectSerializer::toQueryValue($include_raw_data, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
