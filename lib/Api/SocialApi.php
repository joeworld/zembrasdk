<?php
/**
 * SocialApi
 * PHP version 5
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Zembra - API Reference
 *
 * Zembra is a REST API. It accepts standard verbs and returns JSON responses with standard HTTP response codes.    You can use the sandbox token and endpoints for testing. Using the sandbox does not affect your account's balance. Nevertheless, the same throttling applies to both live and sandbox environments. The sandbox randomly returns dummy data representing all different expected responses from an endpoint. The sandbox performs the same set of validation the live box does, including slug validation and eligibility for services.    Default throttling is set to **10000** calls per minute. Your account may have higher limit. If you don't know your current rate limit, contact your account manager or reach out to our [support team](mailto:contact@zembratech.com).  Each response returned by the API has throttling info added to the headers: - **X-RateLimit-Limit**: 10000 or -1 if no limit   The allocated rate limit to the account - **X-RateLimit-Remaining**: < 10000 or -1 if no limit   The number of remaining calls before hitting the throttling limit and start getting calls rejected until counter is reset.    Zembra has made available SDKs in many coding languages to help you quickly get started consuming the API with minimum effort:   - [C-Sharp](https://cdn.sdks.zembratech.com/zembra-sdk-csharp.zip) - [Go](https://cdn.sdks.zembratech.com/zembra-sdk-go.zip) - [Java](https://cdn.sdks.zembratech.com/zembra-sdk-java.zip) - [Kotlin](https://cdn.sdks.zembratech.com/zembra-sdk-kotlin.zip) - [PHP](https://cdn.sdks.zembratech.com/zembra-sdk-php.zip) - [Python](https://cdn.sdks.zembratech.com/zembra-sdk-python.zip) - [Scala](https://cdn.sdks.zembratech.com/zembra-sdk-scala.zip) - [Swift 3](https://cdn.sdks.zembratech.com/zembra-sdk-swift3.zip) - [Swift 4](https://cdn.sdks.zembratech.com/zembra-sdk-swift4.zip) - [Swift 5](https://cdn.sdks.zembratech.com/zembra-sdk-swift5.zip) - [Typescript Angular](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-angular.zip) - [Typescript Fetch](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-fetch.zip)  You can also download [Postman](https://www.postman.com/downloads/) then import this [collection](https://www.getpostman.com/collections/57d319ce3e3bb1150bc6) which includes calls the all Zembra API sandbox endpoints with a combination of all available parameters.
 *
 * OpenAPI spec version: 2.3.0
 * Contact: contact@zembratech.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Zembra Codegen version: 3.0.35
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Zembra\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zembra\Client\ApiException;
use Zembra\Client\Configuration;
use Zembra\Client\HeaderSelector;
use Zembra\Client\ObjectSerializer;

/**
 * SocialApi Class Doc Comment
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SocialApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation socialNetworkContentSlugGet
     *
     * Get details about content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to access details. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2007
     */
    public function socialNetworkContentSlugGet($network, $content, $slug)
    {
        list($response) = $this->socialNetworkContentSlugGetWithHttpInfo($network, $content, $slug);
        return $response;
    }

    /**
     * Operation socialNetworkContentSlugGetWithHttpInfo
     *
     * Get details about content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to access details. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialNetworkContentSlugGetWithHttpInfo($network, $content, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2007';
        $request = $this->socialNetworkContentSlugGetRequest($network, $content, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialNetworkContentSlugGetAsync
     *
     * Get details about content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to access details. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialNetworkContentSlugGetAsync($network, $content, $slug)
    {
        return $this->socialNetworkContentSlugGetAsyncWithHttpInfo($network, $content, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialNetworkContentSlugGetAsyncWithHttpInfo
     *
     * Get details about content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to access details. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialNetworkContentSlugGetAsyncWithHttpInfo($network, $content, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2007';
        $request = $this->socialNetworkContentSlugGetRequest($network, $content, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialNetworkContentSlugGet'
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to access details. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialNetworkContentSlugGetRequest($network, $content, $slug)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialNetworkContentSlugGet'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialNetworkContentSlugGet'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialNetworkContentSlugGet'
            );
        }

        $resourcePath = '/social/{network}/{content}/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialNetworkContentSlugSubContentGet
     *
     * Stream social content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to stream data from. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     * @param  \Zembra\Client\Model\SubContent $sub_content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one sub-content to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $stream_size_limit Instructs the API to only collect up to this number of sub-contents. For example, an Instagram post may have thousands of comments but you are only interested in the first 500. This will make the pulling process abort at the 500th element. Nevertheless, and because we continue to monitor the resource for new elements, during the subscription period you will continue to accrue charges for the new content. With the same example, if the same post receives 100 new posts, we will send you the data and charge your account for the new 100 posts. (optional)
     * @param  int $stream_date_limit Instructs the API to only collect sub-contents posted after and not older than this timestamp. For example, an Instagram post may have thousands of comments but you are only interested in those that were posted the last 24 hours. The pulling process will stop as soon as the older comments are collected. Monitoring will continue for new comments and will impact the credits balance. The account is only charged for eligible comments. The format must be UNIX timestamp in seconds. The maximum acceptable value is the equivalent of 5 minutes from current UTC timestamp. (optional)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the resource in your database, particularly when you activate listeners and we send you a webhook call. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     * @param  int $limit Indicates the maximum number of sub-contents to be returned (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2008
     */
    public function socialNetworkContentSlugSubContentGet($network, $content, $slug, $sub_content, $stream_size_limit = null, $stream_date_limit = null, $internal_id = null, $limit = null)
    {
        list($response) = $this->socialNetworkContentSlugSubContentGetWithHttpInfo($network, $content, $slug, $sub_content, $stream_size_limit, $stream_date_limit, $internal_id, $limit);
        return $response;
    }

    /**
     * Operation socialNetworkContentSlugSubContentGetWithHttpInfo
     *
     * Stream social content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to stream data from. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     * @param  \Zembra\Client\Model\SubContent $sub_content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one sub-content to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $stream_size_limit Instructs the API to only collect up to this number of sub-contents. For example, an Instagram post may have thousands of comments but you are only interested in the first 500. This will make the pulling process abort at the 500th element. Nevertheless, and because we continue to monitor the resource for new elements, during the subscription period you will continue to accrue charges for the new content. With the same example, if the same post receives 100 new posts, we will send you the data and charge your account for the new 100 posts. (optional)
     * @param  int $stream_date_limit Instructs the API to only collect sub-contents posted after and not older than this timestamp. For example, an Instagram post may have thousands of comments but you are only interested in those that were posted the last 24 hours. The pulling process will stop as soon as the older comments are collected. Monitoring will continue for new comments and will impact the credits balance. The account is only charged for eligible comments. The format must be UNIX timestamp in seconds. The maximum acceptable value is the equivalent of 5 minutes from current UTC timestamp. (optional)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the resource in your database, particularly when you activate listeners and we send you a webhook call. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     * @param  int $limit Indicates the maximum number of sub-contents to be returned (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialNetworkContentSlugSubContentGetWithHttpInfo($network, $content, $slug, $sub_content, $stream_size_limit = null, $stream_date_limit = null, $internal_id = null, $limit = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->socialNetworkContentSlugSubContentGetRequest($network, $content, $slug, $sub_content, $stream_size_limit, $stream_date_limit, $internal_id, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialNetworkContentSlugSubContentGetAsync
     *
     * Stream social content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to stream data from. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     * @param  \Zembra\Client\Model\SubContent $sub_content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one sub-content to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $stream_size_limit Instructs the API to only collect up to this number of sub-contents. For example, an Instagram post may have thousands of comments but you are only interested in the first 500. This will make the pulling process abort at the 500th element. Nevertheless, and because we continue to monitor the resource for new elements, during the subscription period you will continue to accrue charges for the new content. With the same example, if the same post receives 100 new posts, we will send you the data and charge your account for the new 100 posts. (optional)
     * @param  int $stream_date_limit Instructs the API to only collect sub-contents posted after and not older than this timestamp. For example, an Instagram post may have thousands of comments but you are only interested in those that were posted the last 24 hours. The pulling process will stop as soon as the older comments are collected. Monitoring will continue for new comments and will impact the credits balance. The account is only charged for eligible comments. The format must be UNIX timestamp in seconds. The maximum acceptable value is the equivalent of 5 minutes from current UTC timestamp. (optional)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the resource in your database, particularly when you activate listeners and we send you a webhook call. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     * @param  int $limit Indicates the maximum number of sub-contents to be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialNetworkContentSlugSubContentGetAsync($network, $content, $slug, $sub_content, $stream_size_limit = null, $stream_date_limit = null, $internal_id = null, $limit = null)
    {
        return $this->socialNetworkContentSlugSubContentGetAsyncWithHttpInfo($network, $content, $slug, $sub_content, $stream_size_limit, $stream_date_limit, $internal_id, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialNetworkContentSlugSubContentGetAsyncWithHttpInfo
     *
     * Stream social content
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to stream data from. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     * @param  \Zembra\Client\Model\SubContent $sub_content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one sub-content to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $stream_size_limit Instructs the API to only collect up to this number of sub-contents. For example, an Instagram post may have thousands of comments but you are only interested in the first 500. This will make the pulling process abort at the 500th element. Nevertheless, and because we continue to monitor the resource for new elements, during the subscription period you will continue to accrue charges for the new content. With the same example, if the same post receives 100 new posts, we will send you the data and charge your account for the new 100 posts. (optional)
     * @param  int $stream_date_limit Instructs the API to only collect sub-contents posted after and not older than this timestamp. For example, an Instagram post may have thousands of comments but you are only interested in those that were posted the last 24 hours. The pulling process will stop as soon as the older comments are collected. Monitoring will continue for new comments and will impact the credits balance. The account is only charged for eligible comments. The format must be UNIX timestamp in seconds. The maximum acceptable value is the equivalent of 5 minutes from current UTC timestamp. (optional)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the resource in your database, particularly when you activate listeners and we send you a webhook call. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     * @param  int $limit Indicates the maximum number of sub-contents to be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialNetworkContentSlugSubContentGetAsyncWithHttpInfo($network, $content, $slug, $sub_content, $stream_size_limit = null, $stream_date_limit = null, $internal_id = null, $limit = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->socialNetworkContentSlugSubContentGetRequest($network, $content, $slug, $sub_content, $stream_size_limit, $stream_date_limit, $internal_id, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialNetworkContentSlugSubContentGet'
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what object you are trying to stream data from. (required)
     * @param  \Zembra\Client\Model\Slug $slug For this endpoint, the slug can only be the short version from the URI. Full URLs are not accepted. (required)
     * @param  \Zembra\Client\Model\SubContent $sub_content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one sub-content to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $stream_size_limit Instructs the API to only collect up to this number of sub-contents. For example, an Instagram post may have thousands of comments but you are only interested in the first 500. This will make the pulling process abort at the 500th element. Nevertheless, and because we continue to monitor the resource for new elements, during the subscription period you will continue to accrue charges for the new content. With the same example, if the same post receives 100 new posts, we will send you the data and charge your account for the new 100 posts. (optional)
     * @param  int $stream_date_limit Instructs the API to only collect sub-contents posted after and not older than this timestamp. For example, an Instagram post may have thousands of comments but you are only interested in those that were posted the last 24 hours. The pulling process will stop as soon as the older comments are collected. Monitoring will continue for new comments and will impact the credits balance. The account is only charged for eligible comments. The format must be UNIX timestamp in seconds. The maximum acceptable value is the equivalent of 5 minutes from current UTC timestamp. (optional)
     * @param  string $internal_id This is your application&#x27;s internal ID. It can help you identify the resource in your database, particularly when you activate listeners and we send you a webhook call. You can include it in all requests or just in the very first one. Omitting this field keeps the saved value unchanged. If you wish to delete your saved internalId, simply set it to empty string. (optional)
     * @param  int $limit Indicates the maximum number of sub-contents to be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialNetworkContentSlugSubContentGetRequest($network, $content, $slug, $sub_content, $stream_size_limit = null, $stream_date_limit = null, $internal_id = null, $limit = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialNetworkContentSlugSubContentGet'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialNetworkContentSlugSubContentGet'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialNetworkContentSlugSubContentGet'
            );
        }
        // verify the required parameter 'sub_content' is set
        if ($sub_content === null || (is_array($sub_content) && count($sub_content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_content when calling socialNetworkContentSlugSubContentGet'
            );
        }

        $resourcePath = '/social/{network}/{content}/{slug}/{subContent}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stream_size_limit !== null) {
            $queryParams['streamSizeLimit'] = ObjectSerializer::toQueryValue($stream_size_limit, null);
        }
        // query params
        if ($stream_date_limit !== null) {
            $queryParams['streamDateLimit'] = ObjectSerializer::toQueryValue($stream_date_limit, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($sub_content !== null) {
            $resourcePath = str_replace(
                '{' . 'subContent' . '}',
                ObjectSerializer::toPathValue($sub_content),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
