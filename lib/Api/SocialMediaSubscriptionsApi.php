<?php
/**
 * SocialMediaSubscriptionsApi
 * PHP version 5
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Zembra - API Reference
 *
 * Zembra is a REST API. It accepts standard verbs and returns JSON responses with standard HTTP response codes.    You can use the sandbox token and endpoints for testing. Using the sandbox does not affect your account's balance. Nevertheless, the same throttling applies to both live and sandbox environments combined. The sandbox randomly returns dummy data representing all different expected responses from an endpoint. The sandbox performs the same set of validation the live box does, including slug validation and eligibility for services.    Default throttling is set to **100** calls per minute. Your account may have a higher limit. If you don't know your current rate limit, contact your account manager or reach out to our [support team](mailto:contact@zembratech.com).  Each response returned by the API has throttling info added to the headers: - **X-RateLimit-Limit**: 100 or -1 if no limit   The allocated rate limit to the account - **X-RateLimit-Remaining**: < 100 or -1 if no limit   The number of remaining calls before hitting the throttling limit and start getting calls rejected until the counter is reset.    Zembra has made SDKs available in many coding languages to help you quickly get started consuming the API with minimum effort:   - [C-Sharp](https://cdn.sdks.zembratech.com/zembra-sdk-csharp.zip) - [Go](https://cdn.sdks.zembratech.com/zembra-sdk-go.zip) - [Java](https://cdn.sdks.zembratech.com/zembra-sdk-java.zip) - [Kotlin](https://cdn.sdks.zembratech.com/zembra-sdk-kotlin.zip) - [PHP](https://cdn.sdks.zembratech.com/zembra-sdk-php.zip) - [Python](https://cdn.sdks.zembratech.com/zembra-sdk-python.zip) - [Scala](https://cdn.sdks.zembratech.com/zembra-sdk-scala.zip) - [Swift 3](https://cdn.sdks.zembratech.com/zembra-sdk-swift3.zip) - [Swift 4](https://cdn.sdks.zembratech.com/zembra-sdk-swift4.zip) - [Swift 5](https://cdn.sdks.zembratech.com/zembra-sdk-swift5.zip) - [Typescript Angular](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-angular.zip) - [Typescript Fetch](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-fetch.zip)  You can also download [Postman](https://www.postman.com/downloads/) then import this [collection](https://docs.zembra.io/zembra-api-postman-collection.json) which includes calls the all Zembra API sandbox endpoints with a combination of all available parameters.
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@zembratech.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Zembra Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Zembra\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zembra\Client\ApiException;
use Zembra\Client\Configuration;
use Zembra\Client\HeaderSelector;
use Zembra\Client\ObjectSerializer;

/**
 * SocialMediaSubscriptionsApi Class Doc Comment
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SocialMediaSubscriptionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentDelete
     *
     * Delete a social media subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20016
     */
    public function socialSubscriptionNetworkResourceSlugContentDelete($network, $resource, $slug, $content)
    {
        list($response) = $this->socialSubscriptionNetworkResourceSlugContentDeleteWithHttpInfo($network, $resource, $slug, $content);
        return $response;
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentDeleteWithHttpInfo
     *
     * Delete a social media subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionNetworkResourceSlugContentDeleteWithHttpInfo($network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20016';
        $request = $this->socialSubscriptionNetworkResourceSlugContentDeleteRequest($network, $resource, $slug, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentDeleteAsync
     *
     * Delete a social media subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentDeleteAsync($network, $resource, $slug, $content)
    {
        return $this->socialSubscriptionNetworkResourceSlugContentDeleteAsyncWithHttpInfo($network, $resource, $slug, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentDeleteAsyncWithHttpInfo
     *
     * Delete a social media subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentDeleteAsyncWithHttpInfo($network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20016';
        $request = $this->socialSubscriptionNetworkResourceSlugContentDeleteRequest($network, $resource, $slug, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionNetworkResourceSlugContentDelete'
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionNetworkResourceSlugContentDeleteRequest($network, $resource, $slug, $content)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialSubscriptionNetworkResourceSlugContentDelete'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling socialSubscriptionNetworkResourceSlugContentDelete'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialSubscriptionNetworkResourceSlugContentDelete'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialSubscriptionNetworkResourceSlugContentDelete'
            );
        }

        $resourcePath = '/social/subscription/{network}/{resource}/{slug}/{content}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($resource !== null) {
            $resourcePath = str_replace(
                '{' . 'resource' . '}',
                ObjectSerializer::toPathValue($resource),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentGet
     *
     * Get social media content from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20015
     */
    public function socialSubscriptionNetworkResourceSlugContentGet($network, $resource, $slug, $content, $limit = '1000', $offset = null)
    {
        list($response) = $this->socialSubscriptionNetworkResourceSlugContentGetWithHttpInfo($network, $resource, $slug, $content, $limit, $offset);
        return $response;
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentGetWithHttpInfo
     *
     * Get social media content from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionNetworkResourceSlugContentGetWithHttpInfo($network, $resource, $slug, $content, $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20015';
        $request = $this->socialSubscriptionNetworkResourceSlugContentGetRequest($network, $resource, $slug, $content, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2062',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentGetAsync
     *
     * Get social media content from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentGetAsync($network, $resource, $slug, $content, $limit = '1000', $offset = null)
    {
        return $this->socialSubscriptionNetworkResourceSlugContentGetAsyncWithHttpInfo($network, $resource, $slug, $content, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentGetAsyncWithHttpInfo
     *
     * Get social media content from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentGetAsyncWithHttpInfo($network, $resource, $slug, $content, $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20015';
        $request = $this->socialSubscriptionNetworkResourceSlugContentGetRequest($network, $resource, $slug, $content, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionNetworkResourceSlugContentGet'
     *
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionNetworkResourceSlugContentGetRequest($network, $resource, $slug, $content, $limit = '1000', $offset = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialSubscriptionNetworkResourceSlugContentGet'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling socialSubscriptionNetworkResourceSlugContentGet'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialSubscriptionNetworkResourceSlugContentGet'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialSubscriptionNetworkResourceSlugContentGet'
            );
        }

        $resourcePath = '/social/subscription/{network}/{resource}/{slug}/{content}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($resource !== null) {
            $resourcePath = str_replace(
                '{' . 'resource' . '}',
                ObjectSerializer::toPathValue($resource),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPatch
     *
     * Update an active social media subscription by slug
     *
     * @param  string $internal_id internal_id (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20017
     */
    public function socialSubscriptionNetworkResourceSlugContentPatch($internal_id, $network, $resource, $slug, $content)
    {
        list($response) = $this->socialSubscriptionNetworkResourceSlugContentPatchWithHttpInfo($internal_id, $network, $resource, $slug, $content);
        return $response;
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPatchWithHttpInfo
     *
     * Update an active social media subscription by slug
     *
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionNetworkResourceSlugContentPatchWithHttpInfo($internal_id, $network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20017';
        $request = $this->socialSubscriptionNetworkResourceSlugContentPatchRequest($internal_id, $network, $resource, $slug, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPatchAsync
     *
     * Update an active social media subscription by slug
     *
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentPatchAsync($internal_id, $network, $resource, $slug, $content)
    {
        return $this->socialSubscriptionNetworkResourceSlugContentPatchAsyncWithHttpInfo($internal_id, $network, $resource, $slug, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPatchAsyncWithHttpInfo
     *
     * Update an active social media subscription by slug
     *
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentPatchAsyncWithHttpInfo($internal_id, $network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20017';
        $request = $this->socialSubscriptionNetworkResourceSlugContentPatchRequest($internal_id, $network, $resource, $slug, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionNetworkResourceSlugContentPatch'
     *
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionNetworkResourceSlugContentPatchRequest($internal_id, $network, $resource, $slug, $content)
    {
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling socialSubscriptionNetworkResourceSlugContentPatch'
            );
        }
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialSubscriptionNetworkResourceSlugContentPatch'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling socialSubscriptionNetworkResourceSlugContentPatch'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialSubscriptionNetworkResourceSlugContentPatch'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialSubscriptionNetworkResourceSlugContentPatch'
            );
        }

        $resourcePath = '/social/subscription/{network}/{resource}/{slug}/{content}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($resource !== null) {
            $resourcePath = str_replace(
                '{' . 'resource' . '}',
                ObjectSerializer::toPathValue($resource),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }

        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPost
     *
     * Create a new subscription to a social media resource stream
     *
     * @param  string $internal_id internal_id (required)
     * @param  int $stream_size_limit stream_size_limit (required)
     * @param  int $stream_date_limit stream_date_limit (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2014
     */
    public function socialSubscriptionNetworkResourceSlugContentPost($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
    {
        list($response) = $this->socialSubscriptionNetworkResourceSlugContentPostWithHttpInfo($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content);
        return $response;
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPostWithHttpInfo
     *
     * Create a new subscription to a social media resource stream
     *
     * @param  string $internal_id (required)
     * @param  int $stream_size_limit (required)
     * @param  int $stream_date_limit (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2014, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionNetworkResourceSlugContentPostWithHttpInfo($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2014';
        $request = $this->socialSubscriptionNetworkResourceSlugContentPostRequest($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPostAsync
     *
     * Create a new subscription to a social media resource stream
     *
     * @param  string $internal_id (required)
     * @param  int $stream_size_limit (required)
     * @param  int $stream_date_limit (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentPostAsync($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
    {
        return $this->socialSubscriptionNetworkResourceSlugContentPostAsyncWithHttpInfo($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionNetworkResourceSlugContentPostAsyncWithHttpInfo
     *
     * Create a new subscription to a social media resource stream
     *
     * @param  string $internal_id (required)
     * @param  int $stream_size_limit (required)
     * @param  int $stream_date_limit (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionNetworkResourceSlugContentPostAsyncWithHttpInfo($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2014';
        $request = $this->socialSubscriptionNetworkResourceSlugContentPostRequest($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionNetworkResourceSlugContentPost'
     *
     * @param  string $internal_id (required)
     * @param  int $stream_size_limit (required)
     * @param  int $stream_date_limit (required)
     * @param  \Zembra\Client\Model\SocialNetwork $network Target social network (required)
     * @param  \Zembra\Client\Model\Resource $resource Depending on the selected network, this will define what object you are trying to access details.    List of available resources varies by network:   - **Facebook**:   - page   - post - **Instagram**:   - hashtag   - post   - user - **LinkedIn**:   - company   - keyword   - profile   - post - **Reddit**:   - keyword   - post   - subreddit   - user - **TokTok**:   - hashtag   - user   - video (required)
     * @param  \Zembra\Client\Model\SocialSlug $slug Unique resource identifier. Full URLs are not accepted. Varies by network. Here are a few examples per resource:   - **Facebook**:   - Page: Presidence.tn   - Post: S:_I1391675561076747:3140064409571178 - **Instagram**:   - Hashtag: coupleprayer   - Post: CFzAp7DASJ0   - User: soumaya_belkouchi - **LinkedIn**:   - Company: zembra   - Keyword: san+diego   - Profile: bakayoko   - Post: urn:li:ugcPost:6971444261015724033 - **Reddit**:   - Keyword: sandiego   - Post: 12mizot   - Subreddit: Damnthatsinteresting   - User: coastalJuncture - **TokTok**:   - Hashtag: healthy   - User: justqueen1988   - Video: 7114961878434041094 (required)
     * @param  \Zembra\Client\Model\Content $content Depending on the selected network, this will define what data you want to stream. This is needed because under one source there could be more than one content type to be streamed. Example, for Instagram users, you may want to pull all comments or all reels. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionNetworkResourceSlugContentPostRequest($internal_id, $stream_size_limit, $stream_date_limit, $network, $resource, $slug, $content)
    {
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'stream_size_limit' is set
        if ($stream_size_limit === null || (is_array($stream_size_limit) && count($stream_size_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_size_limit when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'stream_date_limit' is set
        if ($stream_date_limit === null || (is_array($stream_date_limit) && count($stream_date_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_date_limit when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }
        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content when calling socialSubscriptionNetworkResourceSlugContentPost'
            );
        }

        $resourcePath = '/social/subscription/{network}/{resource}/{slug}/{content}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($resource !== null) {
            $resourcePath = str_replace(
                '{' . 'resource' . '}',
                ObjectSerializer::toPathValue($resource),
                $resourcePath
            );
        }
        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($content !== null) {
            $resourcePath = str_replace(
                '{' . 'content' . '}',
                ObjectSerializer::toPathValue($content),
                $resourcePath
            );
        }

        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // form params
        if ($stream_size_limit !== null) {
            $formParams['streamSizeLimit'] = ObjectSerializer::toFormValue($stream_size_limit);
        }
        // form params
        if ($stream_date_limit !== null) {
            $formParams['streamDateLimit'] = ObjectSerializer::toFormValue($stream_date_limit);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionUidUidDelete
     *
     * Delete a social media subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20016
     */
    public function socialSubscriptionUidUidDelete($uid)
    {
        list($response) = $this->socialSubscriptionUidUidDeleteWithHttpInfo($uid);
        return $response;
    }

    /**
     * Operation socialSubscriptionUidUidDeleteWithHttpInfo
     *
     * Delete a social media subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionUidUidDeleteWithHttpInfo($uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20016';
        $request = $this->socialSubscriptionUidUidDeleteRequest($uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionUidUidDeleteAsync
     *
     * Delete a social media subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidDeleteAsync($uid)
    {
        return $this->socialSubscriptionUidUidDeleteAsyncWithHttpInfo($uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionUidUidDeleteAsyncWithHttpInfo
     *
     * Delete a social media subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidDeleteAsyncWithHttpInfo($uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20016';
        $request = $this->socialSubscriptionUidUidDeleteRequest($uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionUidUidDelete'
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionUidUidDeleteRequest($uid)
    {
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling socialSubscriptionUidUidDelete'
            );
        }

        $resourcePath = '/social/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionUidUidGet
     *
     * Get social media content from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20015
     */
    public function socialSubscriptionUidUidGet($uid, $limit = '1000', $offset = null)
    {
        list($response) = $this->socialSubscriptionUidUidGetWithHttpInfo($uid, $limit, $offset);
        return $response;
    }

    /**
     * Operation socialSubscriptionUidUidGetWithHttpInfo
     *
     * Get social media content from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionUidUidGetWithHttpInfo($uid, $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20015';
        $request = $this->socialSubscriptionUidUidGetRequest($uid, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2062',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionUidUidGetAsync
     *
     * Get social media content from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidGetAsync($uid, $limit = '1000', $offset = null)
    {
        return $this->socialSubscriptionUidUidGetAsyncWithHttpInfo($uid, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionUidUidGetAsyncWithHttpInfo
     *
     * Get social media content from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidGetAsyncWithHttpInfo($uid, $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20015';
        $request = $this->socialSubscriptionUidUidGetRequest($uid, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionUidUidGet'
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  int $limit Indicates the maximum number of elements to be returned. The default limit will be applied if omitted. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of elements. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionUidUidGetRequest($uid, $limit = '1000', $offset = null)
    {
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling socialSubscriptionUidUidGet'
            );
        }

        $resourcePath = '/social/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }

        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionUidUidPatch
     *
     * Update an active social media subscription by UID
     *
     * @param  string $internal_id internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20017
     */
    public function socialSubscriptionUidUidPatch($internal_id, $uid)
    {
        list($response) = $this->socialSubscriptionUidUidPatchWithHttpInfo($internal_id, $uid);
        return $response;
    }

    /**
     * Operation socialSubscriptionUidUidPatchWithHttpInfo
     *
     * Update an active social media subscription by UID
     *
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionUidUidPatchWithHttpInfo($internal_id, $uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20017';
        $request = $this->socialSubscriptionUidUidPatchRequest($internal_id, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionUidUidPatchAsync
     *
     * Update an active social media subscription by UID
     *
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidPatchAsync($internal_id, $uid)
    {
        return $this->socialSubscriptionUidUidPatchAsyncWithHttpInfo($internal_id, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionUidUidPatchAsyncWithHttpInfo
     *
     * Update an active social media subscription by UID
     *
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionUidUidPatchAsyncWithHttpInfo($internal_id, $uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20017';
        $request = $this->socialSubscriptionUidUidPatchRequest($internal_id, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionUidUidPatch'
     *
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionUidUidPatchRequest($internal_id, $uid)
    {
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling socialSubscriptionUidUidPatch'
            );
        }
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling socialSubscriptionUidUidPatch'
            );
        }

        $resourcePath = '/social/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSubscriptionsGet
     *
     * Get the list of social media subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\SocialSlug $slug Filter results to only subscriptions to resources with similar slug. (optional)
     * @param  \Zembra\Client\Model\SocialNetwork $network Returns subscriptions only from the requested network. (optional)
     * @param  \Zembra\Client\Model\Resource $resource Limits subscriptions to only those that match the selected resource type. (optional)
     * @param  \Zembra\Client\Model\Content $content Limits subscriptions to only those that match the selected content type. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20018
     */
    public function socialSubscriptionsGet($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $resource = null, $content = null)
    {
        list($response) = $this->socialSubscriptionsGetWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $resource, $content);
        return $response;
    }

    /**
     * Operation socialSubscriptionsGetWithHttpInfo
     *
     * Get the list of social media subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\SocialSlug $slug Filter results to only subscriptions to resources with similar slug. (optional)
     * @param  \Zembra\Client\Model\SocialNetwork $network Returns subscriptions only from the requested network. (optional)
     * @param  \Zembra\Client\Model\Resource $resource Limits subscriptions to only those that match the selected resource type. (optional)
     * @param  \Zembra\Client\Model\Content $content Limits subscriptions to only those that match the selected content type. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSubscriptionsGetWithHttpInfo($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $resource = null, $content = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20018';
        $request = $this->socialSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $resource, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSubscriptionsGetAsync
     *
     * Get the list of social media subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\SocialSlug $slug Filter results to only subscriptions to resources with similar slug. (optional)
     * @param  \Zembra\Client\Model\SocialNetwork $network Returns subscriptions only from the requested network. (optional)
     * @param  \Zembra\Client\Model\Resource $resource Limits subscriptions to only those that match the selected resource type. (optional)
     * @param  \Zembra\Client\Model\Content $content Limits subscriptions to only those that match the selected content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionsGetAsync($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $resource = null, $content = null)
    {
        return $this->socialSubscriptionsGetAsyncWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $resource, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSubscriptionsGetAsyncWithHttpInfo
     *
     * Get the list of social media subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\SocialSlug $slug Filter results to only subscriptions to resources with similar slug. (optional)
     * @param  \Zembra\Client\Model\SocialNetwork $network Returns subscriptions only from the requested network. (optional)
     * @param  \Zembra\Client\Model\Resource $resource Limits subscriptions to only those that match the selected resource type. (optional)
     * @param  \Zembra\Client\Model\Content $content Limits subscriptions to only those that match the selected content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSubscriptionsGetAsyncWithHttpInfo($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $resource = null, $content = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20018';
        $request = $this->socialSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network, $resource, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSubscriptionsGet'
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\SocialSlug $slug Filter results to only subscriptions to resources with similar slug. (optional)
     * @param  \Zembra\Client\Model\SocialNetwork $network Returns subscriptions only from the requested network. (optional)
     * @param  \Zembra\Client\Model\Resource $resource Limits subscriptions to only those that match the selected resource type. (optional)
     * @param  \Zembra\Client\Model\Content $content Limits subscriptions to only those that match the selected content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function socialSubscriptionsGetRequest($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null, $resource = null, $content = null)
    {

        $resourcePath = '/social/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($network !== null) {
            $queryParams['network'] = ObjectSerializer::toQueryValue($network, null);
        }
        // query params
        if ($resource !== null) {
            $queryParams['resource'] = ObjectSerializer::toQueryValue($resource, null);
        }
        // query params
        if ($content !== null) {
            $queryParams['content'] = ObjectSerializer::toQueryValue($content, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
