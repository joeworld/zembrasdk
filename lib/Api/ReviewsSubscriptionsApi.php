<?php
/**
 * ReviewsSubscriptionsApi
 * PHP version 5
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Zembra - API Reference
 *
 * Zembra is a REST API. It accepts standard verbs and returns JSON responses with standard HTTP response codes.    You can use the sandbox token and endpoints for testing. Using the sandbox does not affect your account's balance. Nevertheless, the same throttling applies to both live and sandbox environments combined. The sandbox randomly returns dummy data representing all different expected responses from an endpoint. The sandbox performs the same set of validation the live box does, including slug validation and eligibility for services.    Default throttling is set to **100** calls per minute. Your account may have a higher limit. If you don't know your current rate limit, contact your account manager or reach out to our [support team](mailto:contact@zembratech.com).  Each response returned by the API has throttling info added to the headers: - **X-RateLimit-Limit**: 100 or -1 if no limit   The allocated rate limit to the account - **X-RateLimit-Remaining**: < 100 or -1 if no limit   The number of remaining calls before hitting the throttling limit and start getting calls rejected until the counter is reset.    Zembra has made SDKs available in many coding languages to help you quickly get started consuming the API with minimum effort:   - [C-Sharp](https://cdn.sdks.zembratech.com/zembra-sdk-csharp.zip) - [Go](https://cdn.sdks.zembratech.com/zembra-sdk-go.zip) - [Java](https://cdn.sdks.zembratech.com/zembra-sdk-java.zip) - [Kotlin](https://cdn.sdks.zembratech.com/zembra-sdk-kotlin.zip) - [PHP](https://cdn.sdks.zembratech.com/zembra-sdk-php.zip) - [Python](https://cdn.sdks.zembratech.com/zembra-sdk-python.zip) - [Scala](https://cdn.sdks.zembratech.com/zembra-sdk-scala.zip) - [Swift 3](https://cdn.sdks.zembratech.com/zembra-sdk-swift3.zip) - [Swift 4](https://cdn.sdks.zembratech.com/zembra-sdk-swift4.zip) - [Swift 5](https://cdn.sdks.zembratech.com/zembra-sdk-swift5.zip) - [Typescript Angular](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-angular.zip) - [Typescript Fetch](https://cdn.sdks.zembratech.com/zembra-sdk-typescript-fetch.zip)  You can also download [Postman](https://www.postman.com/downloads/) then import this [collection](https://docs.zembra.io/zembra-api-postman-collection.json) which includes calls the all Zembra API sandbox endpoints with a combination of all available parameters.
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@zembratech.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Zembra Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Zembra\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zembra\Client\ApiException;
use Zembra\Client\Configuration;
use Zembra\Client\HeaderSelector;
use Zembra\Client\ObjectSerializer;

/**
 * ReviewsSubscriptionsApi Class Doc Comment
 *
 * @category Class
 * @package  Zembra\Client
 * @author   Zembra Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReviewsSubscriptionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation reviewsSubscriptionNetworkDelete
     *
     * Delete a review page subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2009
     */
    public function reviewsSubscriptionNetworkDelete($network, $slug)
    {
        list($response) = $this->reviewsSubscriptionNetworkDeleteWithHttpInfo($network, $slug);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionNetworkDeleteWithHttpInfo
     *
     * Delete a review page subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionNetworkDeleteWithHttpInfo($network, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2009';
        $request = $this->reviewsSubscriptionNetworkDeleteRequest($network, $slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionNetworkDeleteAsync
     *
     * Delete a review page subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkDeleteAsync($network, $slug)
    {
        return $this->reviewsSubscriptionNetworkDeleteAsyncWithHttpInfo($network, $slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionNetworkDeleteAsyncWithHttpInfo
     *
     * Delete a review page subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkDeleteAsyncWithHttpInfo($network, $slug)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2009';
        $request = $this->reviewsSubscriptionNetworkDeleteRequest($network, $slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionNetworkDelete'
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionNetworkDeleteRequest($network, $slug)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionNetworkDelete'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionNetworkDelete'
            );
        }

        $resourcePath = '/reviews/subscription/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionNetworkGet
     *
     * Get reviews of requested business from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2008
     */
    public function reviewsSubscriptionNetworkGet($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        list($response) = $this->reviewsSubscriptionNetworkGetWithHttpInfo($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionNetworkGetWithHttpInfo
     *
     * Get reviews of requested business from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionNetworkGetWithHttpInfo($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->reviewsSubscriptionNetworkGetRequest($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2061',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionNetworkGetAsync
     *
     * Get reviews of requested business from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkGetAsync($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        return $this->reviewsSubscriptionNetworkGetAsyncWithHttpInfo($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionNetworkGetAsyncWithHttpInfo
     *
     * Get reviews of requested business from existing subscription by slug
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkGetAsyncWithHttpInfo($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->reviewsSubscriptionNetworkGetRequest($network, $slug, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionNetworkGet'
     *
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     * @param  \Zembra\Client\Model\Slug $slug Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}** (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionNetworkGetRequest($network, $slug, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionNetworkGet'
            );
        }
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionNetworkGet'
            );
        }

        $resourcePath = '/reviews/subscription/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if (is_array($fields)) {
            $fields = ObjectSerializer::serializeCollection($fields, 'multi', true);
        }
        if ($fields !== null) {
            $queryParams['fields[]'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($has_photos !== null) {
            $queryParams['hasPhotos'] = ObjectSerializer::toQueryValue($has_photos, null);
        }
        // query params
        if ($has_replies !== null) {
            $queryParams['hasReplies'] = ObjectSerializer::toQueryValue($has_replies, null);
        }
        // query params
        if ($has_edits !== null) {
            $queryParams['hasEdits'] = ObjectSerializer::toQueryValue($has_edits, null);
        }
        // query params
        if ($is_hidden !== null) {
            $queryParams['isHidden'] = ObjectSerializer::toQueryValue($is_hidden, null);
        }
        // query params
        if ($is_recommended !== null) {
            $queryParams['isRecommended'] = ObjectSerializer::toQueryValue($is_recommended, null);
        }
        // query params
        if ($max_rating !== null) {
            $queryParams['maxRating'] = ObjectSerializer::toQueryValue($max_rating, 'float');
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating, 'float');
        }
        // query params
        if ($posted_before !== null) {
            $queryParams['postedBefore'] = ObjectSerializer::toQueryValue($posted_before, 'date');
        }
        // query params
        if ($posted_after !== null) {
            $queryParams['postedAfter'] = ObjectSerializer::toQueryValue($posted_after, 'date');
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language, null);
        }
        // query params
        if ($include_deleted !== null) {
            $queryParams['includeDeleted'] = ObjectSerializer::toQueryValue($include_deleted, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }

        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionNetworkPatch
     *
     * Update an active review page subscription by slug
     *
     * @param  string $slug slug (required)
     * @param  bool $include_raw_data include_raw_data (required)
     * @param  bool $auto_renew auto_renew (required)
     * @param  string $internal_id internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the subscription belongs to. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20010
     */
    public function reviewsSubscriptionNetworkPatch($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        list($response) = $this->reviewsSubscriptionNetworkPatchWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionNetworkPatchWithHttpInfo
     *
     * Update an active review page subscription by slug
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the subscription belongs to. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionNetworkPatchWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20010';
        $request = $this->reviewsSubscriptionNetworkPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionNetworkPatchAsync
     *
     * Update an active review page subscription by slug
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the subscription belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkPatchAsync($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        return $this->reviewsSubscriptionNetworkPatchAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionNetworkPatchAsyncWithHttpInfo
     *
     * Update an active review page subscription by slug
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the subscription belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkPatchAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20010';
        $request = $this->reviewsSubscriptionNetworkPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionNetworkPatch'
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network the subscription belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionNetworkPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionNetworkPatch'
            );
        }
        // verify the required parameter 'include_raw_data' is set
        if ($include_raw_data === null || (is_array($include_raw_data) && count($include_raw_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_raw_data when calling reviewsSubscriptionNetworkPatch'
            );
        }
        // verify the required parameter 'auto_renew' is set
        if ($auto_renew === null || (is_array($auto_renew) && count($auto_renew) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $auto_renew when calling reviewsSubscriptionNetworkPatch'
            );
        }
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling reviewsSubscriptionNetworkPatch'
            );
        }
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionNetworkPatch'
            );
        }

        $resourcePath = '/reviews/subscription/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // form params
        if ($slug !== null) {
            $formParams['slug'] = ObjectSerializer::toFormValue($slug);
        }
        // form params
        if ($include_raw_data !== null) {
            $formParams['includeRawData'] = ObjectSerializer::toFormValue($include_raw_data);
        }
        // form params
        if ($auto_renew !== null) {
            $formParams['autoRenew'] = ObjectSerializer::toFormValue($auto_renew);
        }
        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionNetworkPost
     *
     * Create a new subscription to a review page
     *
     * @param  string $slug slug (required)
     * @param  bool $include_raw_data include_raw_data (required)
     * @param  bool $auto_renew auto_renew (required)
     * @param  string $internal_id internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2012
     */
    public function reviewsSubscriptionNetworkPost($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        list($response) = $this->reviewsSubscriptionNetworkPostWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionNetworkPostWithHttpInfo
     *
     * Create a new subscription to a review page
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2012, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionNetworkPostWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2012';
        $request = $this->reviewsSubscriptionNetworkPostRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse402',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse409',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionNetworkPostAsync
     *
     * Create a new subscription to a review page
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkPostAsync($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        return $this->reviewsSubscriptionNetworkPostAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionNetworkPostAsyncWithHttpInfo
     *
     * Create a new subscription to a review page
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionNetworkPostAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2012';
        $request = $this->reviewsSubscriptionNetworkPostRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionNetworkPost'
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Network this business page belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionNetworkPostRequest($slug, $include_raw_data, $auto_renew, $internal_id, $network)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionNetworkPost'
            );
        }
        // verify the required parameter 'include_raw_data' is set
        if ($include_raw_data === null || (is_array($include_raw_data) && count($include_raw_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_raw_data when calling reviewsSubscriptionNetworkPost'
            );
        }
        // verify the required parameter 'auto_renew' is set
        if ($auto_renew === null || (is_array($auto_renew) && count($auto_renew) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $auto_renew when calling reviewsSubscriptionNetworkPost'
            );
        }
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling reviewsSubscriptionNetworkPost'
            );
        }
        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling reviewsSubscriptionNetworkPost'
            );
        }

        $resourcePath = '/reviews/subscription/{network}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }

        // form params
        if ($slug !== null) {
            $formParams['slug'] = ObjectSerializer::toFormValue($slug);
        }
        // form params
        if ($include_raw_data !== null) {
            $formParams['includeRawData'] = ObjectSerializer::toFormValue($include_raw_data);
        }
        // form params
        if ($auto_renew !== null) {
            $formParams['autoRenew'] = ObjectSerializer::toFormValue($auto_renew);
        }
        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionUidUidDelete
     *
     * Delete a review page subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2009
     */
    public function reviewsSubscriptionUidUidDelete($uid)
    {
        list($response) = $this->reviewsSubscriptionUidUidDeleteWithHttpInfo($uid);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionUidUidDeleteWithHttpInfo
     *
     * Delete a review page subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionUidUidDeleteWithHttpInfo($uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2009';
        $request = $this->reviewsSubscriptionUidUidDeleteRequest($uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionUidUidDeleteAsync
     *
     * Delete a review page subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidDeleteAsync($uid)
    {
        return $this->reviewsSubscriptionUidUidDeleteAsyncWithHttpInfo($uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionUidUidDeleteAsyncWithHttpInfo
     *
     * Delete a review page subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidDeleteAsyncWithHttpInfo($uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2009';
        $request = $this->reviewsSubscriptionUidUidDeleteRequest($uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionUidUidDelete'
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionUidUidDeleteRequest($uid)
    {
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling reviewsSubscriptionUidUidDelete'
            );
        }

        $resourcePath = '/reviews/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionUidUidGet
     *
     * Get reviews of requested business from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse2008
     */
    public function reviewsSubscriptionUidUidGet($uid, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        list($response) = $this->reviewsSubscriptionUidUidGetWithHttpInfo($uid, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionUidUidGetWithHttpInfo
     *
     * Get reviews of requested business from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionUidUidGetWithHttpInfo($uid, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->reviewsSubscriptionUidUidGetRequest($uid, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 206:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse2061',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionUidUidGetAsync
     *
     * Get reviews of requested business from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidGetAsync($uid, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        return $this->reviewsSubscriptionUidUidGetAsyncWithHttpInfo($uid, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionUidUidGetAsyncWithHttpInfo
     *
     * Get reviews of requested business from existing subscription by UID
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidGetAsyncWithHttpInfo($uid, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse2008';
        $request = $this->reviewsSubscriptionUidUidGetRequest($uid, $fields, $has_photos, $has_replies, $has_edits, $is_hidden, $is_recommended, $max_rating, $min_rating, $posted_before, $posted_after, $language, $include_deleted, $sort_by, $sort_direction, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionUidUidGet'
     *
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     * @param  string[] $fields List of review fields to be returned (optional)
     * @param  bool $has_photos If requested, only reviews with photos are returned. If set to false, only reviews without photos are returned. To include all reviews regardless of whether they have photos or not, omit this option. (optional)
     * @param  bool $has_replies If requested, only reviews with replies are returned. If set to false, only reviews without replies are returned. To include all reviews regardless of whether they have replies or not, omit this option. (optional)
     * @param  bool $has_edits If requested, only reviews with edits are returned. Edits can be reported by the review platform, like with Yelp, or have been detected by our engines. If set to false, only reviews without edits are returned. To include all reviews regardless of whether they have edits or not, omit this option. (optional)
     * @param  bool $is_hidden If true, only reviews that are kept hidden on the review platform are included, e.g. non-recommended reviews on Yelp. If false, only visible reviews are returned. (optional)
     * @param  bool $is_recommended If true, reviews considered as positive recommendation (recommended) are returned. If false, reviews considered as negative recommendation (not recommended) are included. (optional)
     * @param  float $max_rating Limits the highest rating of the returned reviews. (optional)
     * @param  float $min_rating Limits the lowest rating of the returned reviews. (optional)
     * @param  \DateTime $posted_before Setting this parameter restricts the result to contain only reviews that were posted before the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  \DateTime $posted_after Setting this parameter restricts the result to contain only reviews that were posted after the specified date. The input must respect this format &#x60;Y-m-d H:i:s&#x60; or any derivative starting from the left, e.g. &#x60;Y&#x60; or &#x60;Y-m&#x60;, etc. (optional)
     * @param  string $language Return only reviews which language matches the given string. (optional)
     * @param  bool $include_deleted If requested, the result will include reviews that are detected by the engine as deleted, i.e. reviews that were live at some point then detected missing. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  int $limit Indicates the maximum number of reviews to be returned. If you change the default filters and/or the list of fields and omit the &#x60;limit&#x60; then the default limit will be applied. (optional, default to 1000)
     * @param  int $offset Helps with pagination. It indicates the offset to be applied to the set of reviews. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionUidUidGetRequest($uid, $fields = null, $has_photos = null, $has_replies = null, $has_edits = null, $is_hidden = null, $is_recommended = null, $max_rating = null, $min_rating = null, $posted_before = null, $posted_after = null, $language = null, $include_deleted = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $limit = '1000', $offset = null)
    {
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling reviewsSubscriptionUidUidGet'
            );
        }

        $resourcePath = '/reviews/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($fields)) {
            $fields = ObjectSerializer::serializeCollection($fields, 'multi', true);
        }
        if ($fields !== null) {
            $queryParams['fields[]'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($has_photos !== null) {
            $queryParams['hasPhotos'] = ObjectSerializer::toQueryValue($has_photos, null);
        }
        // query params
        if ($has_replies !== null) {
            $queryParams['hasReplies'] = ObjectSerializer::toQueryValue($has_replies, null);
        }
        // query params
        if ($has_edits !== null) {
            $queryParams['hasEdits'] = ObjectSerializer::toQueryValue($has_edits, null);
        }
        // query params
        if ($is_hidden !== null) {
            $queryParams['isHidden'] = ObjectSerializer::toQueryValue($is_hidden, null);
        }
        // query params
        if ($is_recommended !== null) {
            $queryParams['isRecommended'] = ObjectSerializer::toQueryValue($is_recommended, null);
        }
        // query params
        if ($max_rating !== null) {
            $queryParams['maxRating'] = ObjectSerializer::toQueryValue($max_rating, 'float');
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating, 'float');
        }
        // query params
        if ($posted_before !== null) {
            $queryParams['postedBefore'] = ObjectSerializer::toQueryValue($posted_before, 'date');
        }
        // query params
        if ($posted_after !== null) {
            $queryParams['postedAfter'] = ObjectSerializer::toQueryValue($posted_after, 'date');
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language, null);
        }
        // query params
        if ($include_deleted !== null) {
            $queryParams['includeDeleted'] = ObjectSerializer::toQueryValue($include_deleted, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }

        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionUidUidPatch
     *
     * Update an active review page subscription by UID
     *
     * @param  string $slug slug (required)
     * @param  bool $include_raw_data include_raw_data (required)
     * @param  bool $auto_renew auto_renew (required)
     * @param  string $internal_id internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20010
     */
    public function reviewsSubscriptionUidUidPatch($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
    {
        list($response) = $this->reviewsSubscriptionUidUidPatchWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $uid);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionUidUidPatchWithHttpInfo
     *
     * Update an active review page subscription by UID
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionUidUidPatchWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20010';
        $request = $this->reviewsSubscriptionUidUidPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $uid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionUidUidPatchAsync
     *
     * Update an active review page subscription by UID
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidPatchAsync($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
    {
        return $this->reviewsSubscriptionUidUidPatchAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionUidUidPatchAsyncWithHttpInfo
     *
     * Update an active review page subscription by UID
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionUidUidPatchAsyncWithHttpInfo($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20010';
        $request = $this->reviewsSubscriptionUidUidPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionUidUidPatch'
     *
     * @param  string $slug (required)
     * @param  bool $include_raw_data (required)
     * @param  bool $auto_renew (required)
     * @param  string $internal_id (required)
     * @param  string $uid The UID of the subscription that was returned at the time of creation. It persists over time and across accounts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionUidUidPatchRequest($slug, $include_raw_data, $auto_renew, $internal_id, $uid)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling reviewsSubscriptionUidUidPatch'
            );
        }
        // verify the required parameter 'include_raw_data' is set
        if ($include_raw_data === null || (is_array($include_raw_data) && count($include_raw_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_raw_data when calling reviewsSubscriptionUidUidPatch'
            );
        }
        // verify the required parameter 'auto_renew' is set
        if ($auto_renew === null || (is_array($auto_renew) && count($auto_renew) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $auto_renew when calling reviewsSubscriptionUidUidPatch'
            );
        }
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling reviewsSubscriptionUidUidPatch'
            );
        }
        // verify the required parameter 'uid' is set
        if ($uid === null || (is_array($uid) && count($uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uid when calling reviewsSubscriptionUidUidPatch'
            );
        }

        $resourcePath = '/reviews/subscription/uid/{uid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($uid !== null) {
            $resourcePath = str_replace(
                '{' . 'uid' . '}',
                ObjectSerializer::toPathValue($uid),
                $resourcePath
            );
        }

        // form params
        if ($slug !== null) {
            $formParams['slug'] = ObjectSerializer::toFormValue($slug);
        }
        // form params
        if ($include_raw_data !== null) {
            $formParams['includeRawData'] = ObjectSerializer::toFormValue($include_raw_data);
        }
        // form params
        if ($auto_renew !== null) {
            $formParams['autoRenew'] = ObjectSerializer::toFormValue($auto_renew);
        }
        // form params
        if ($internal_id !== null) {
            $formParams['internalId'] = ObjectSerializer::toFormValue($internal_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsSubscriptionsGet
     *
     * Get the list of reviews subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Zembra\Client\Model\InlineResponse20011
     */
    public function reviewsSubscriptionsGet($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null)
    {
        list($response) = $this->reviewsSubscriptionsGetWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network);
        return $response;
    }

    /**
     * Operation reviewsSubscriptionsGetWithHttpInfo
     *
     * Get the list of reviews subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     *
     * @throws \Zembra\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Zembra\Client\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsSubscriptionsGetWithHttpInfo($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20011';
        $request = $this->reviewsSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Zembra\Client\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsSubscriptionsGetAsync
     *
     * Get the list of reviews subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsGetAsync($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null)
    {
        return $this->reviewsSubscriptionsGetAsyncWithHttpInfo($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsSubscriptionsGetAsyncWithHttpInfo
     *
     * Get the list of reviews subscriptions
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsSubscriptionsGetAsyncWithHttpInfo($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null)
    {
        $returnType = '\Zembra\Client\Model\InlineResponse20011';
        $request = $this->reviewsSubscriptionsGetRequest($limit, $offset, $sort_by, $sort_direction, $internal_id, $slug, $network);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsSubscriptionsGet'
     *
     * @param  int $limit Maximum number of subscriptions to be returned. At most 100 subscriptions will be returned even if this parameter is set to a higher value. (optional, default to 100)
     * @param  int $offset Helps with pagination. It controls the offset to be applied to the set of subscriptions. (optional)
     * @param  string $sort_by Indicates the desired sorting attribute. (optional, default to timestamp)
     * @param  string $sort_direction Indicates the desired sorting direction. (optional, default to DESC)
     * @param  string $internal_id Filter results to only subscriptions with similar internal ID. This is the ID you set on the subscription that identifies it with your application. Please see the description for &#x60;internalId&#x60; on **[POST] /reviews/subscription/{network}**. (optional)
     * @param  \Zembra\Client\Model\Slug $slug Filter results to only subscriptions to review pages with similar slug. Please see the description for &#x60;slug&#x60; on **[GET] /business/{network}**. (optional)
     * @param  \Zembra\Client\Model\ReviewNetwork $network Returns subscriptions to review pages only from the requested network. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsSubscriptionsGetRequest($limit = '100', $offset = null, $sort_by = 'timestamp', $sort_direction = 'DESC', $internal_id = null, $slug = null, $network = null)
    {

        $resourcePath = '/reviews/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction, null);
        }
        // query params
        if ($internal_id !== null) {
            $queryParams['internalId'] = ObjectSerializer::toQueryValue($internal_id, null);
        }
        // query params
        if ($slug !== null) {
            $queryParams['slug'] = ObjectSerializer::toQueryValue($slug, null);
        }
        // query params
        if ($network !== null) {
            $queryParams['network'] = ObjectSerializer::toQueryValue($network, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
